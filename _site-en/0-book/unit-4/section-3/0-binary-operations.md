# 第1章：二項演算のコンテナ持ち上げ - 3つの実装パターン

## 1.1 代数構造としての map2

関数型プログラミングにおいて、`map2` は以下の型シグネチャを持つ：

```fsharp
map2: (a -> b -> c) -> F<a> -> F<b> -> F<c>
```

これは「二項演算のコンテナFへの持ち上げ」を表現し、以下のような代数構造を形成する：

```
F<a> * F<b> = F<c>
```

ここで `(F, *)` というペアが代数構造を規定する。

## 1.2 実装パターンの分類体系

### 第一分岐：依存性による分類

すべての `map2` 実装は、計算の依存性によって2つの大系統に分類される：

1. **独立・並列処理可能**: 2つのコンテナが互いに独立
2. **依存・逐次処理必要**: 一方の計算結果が他方に影響

### 第二分岐：独立系統の内部分類

独立・並列処理可能な系統は、さらに2つに細分化される：

1. **デカルト積 (Cartesian Product)**
2. **ポイントワイズ (Pointwise/ZIP)**

## 1.3 デカルト積パターン - 「九九のテーブル」アプローチ

### 概念説明

デカルト積は、2つの集合のすべての組み合わせを生成する。これは小学校の九九表をイメージすると理解しやすい：

```
× | 1  2  3
--|--------
1 | 1  2  3
2 | 2  4  6
3 | 3  6  9
```

### F# List での実装例

```fsharp
let cartesianMap2 f list1 list2 =
    [for x in list1 do
     for y in list2 do
     yield f x y]

// 使用例
let list1 = [1; 2]
let list2 = [10; 20]
let result = cartesianMap2 (+) list1 list2
// 結果: [11; 21; 12; 22]
// 説明: (1+10), (1+20), (2+10), (2+20)
```