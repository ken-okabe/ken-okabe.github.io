## Haskellの「理論的優位性」という虚構：圏論的視点からの批判的検証

### 序論

Haskellがプログラミングの世界に多大な知的貢献をしてきたことは、否定できない事実である。特にモナドをはじめとする多くの抽象概念の実用的応用を切り拓き、プログラミング界全体に普及させた功績は大きい。その理論的な厳密さと表現力は、今なお多くの開発者や研究者にとって一つのベンチマークであり続けている。

しかし、まさにこの理論的権威のゆえに、特定の設計上の選択が「数学的な必然性」として神話化され、批判的な再検証を困難にしている側面があるのではないか。本稿は、「それはHaskellのローカルルールを、普遍的な数学的議論にすり替えているだけではないか」という根源的な問いから出発する。

この文書の目的は、決してHaskellの全体的な価値を否定することではない。むしろ、長年議論されてきた特定の問題、すなわち**`List`のApplicative実装とそれに関連する型クラス階層**に焦点を当て、この選択が本当に主張されるほど「理論的に自然」なものであるかを、圏論というレンズと、より自然な実装を見せる他言語との比較を通じて、公正かつ厳密に再検証することにある。

### 1. 問題の構造：HaskellにおけるFunctor・Monad・Applicativeの「歪み」

この問題の核心にある理論的な「歪み」を理解するために、まず3つの概念を順に見ていく必要がある。

#### 1-1. 全ての土台：「Functor」

まず、全ての土台となるのが`Functor`である。`map` (Functor) は、単一のコンテナ (`f a`) を扱う最も基本的な操作であり、その役割は、コンテナの構造（リストの長さなど）には一切変更を加えず、中の要素だけを関数 `a -> b` を使って変換（写像）することにある。

`Functor`の`map`の型シグネチャは `(a -> b) -> f a -> f b` であり、「デカルト積」と「Zip」の対立が生じる以前の、中立的で基本的な「写像」操作と見なすことができる。

#### 1-2. 強力な「Monad」とその「デカルト積」的な宿命

次に、`Functor`の力を大きく拡張するのが`Monad`である。`bind` (Monad) は、`m a -> (a -> m b) -> m b`（F#の`collect`やJSの`flatMap`）のような型を持ち、前の計算結果の値`a`を使って、次の計算の**構造**そのもの (`m b`) を決定できるという豊かな能力を持つ。

`List`の文脈において、モナド則を満たす「自然な」実装は、**デカルト積（全組み合わせ）**のように振る舞うものである。これこそが`List`モナドの力の源泉であると同時に、その「個性」を決定づける宿命でもある。

#### 1-3. 問題の源泉：「Applicative」への「押し込み」

最後に`Applicative`を論じる。これはHaskellの型クラスの中では歴史的に比較的新しく、そしてどういうわけか`Functor`と`Monad`の中間層に押し込まれる形で導入された。本稿が繰り返し指摘する問題は、まさにここに発生する。

* **Applicativeの多様性**: 大前提として、`List`に対しては、**「デカルト積」**と**「Zip」**という、圏論的に正当な少なくとも2つの`Applicative`の「選択肢」が存在する。これは`List`型が持つ構造の豊かさを示している。
* **Haskellの階層による「強制」**: しかしHaskellは、`class Applicative f => Monad f`という階層構造を定めた。これは、`Monad`である`List`の`Applicative`の振る舞いを、`Monad`から導出されるデカルト積版に**固定化**してしまう、言語設計上の工学的な決定であった。
* **結果としての「錯覚」と不当な排除**: この「デカルト積が標準で、Zipは特殊」という状況は、Haskellの階層という**工学的な制約が生み出した「錯覚」**に他ならない。Zipの振る舞いは、それ自体が数学的に問題であったわけではなく、単にHaskellが作り出した「`Monad`と`Applicative`はこうあるべき」というローカルルールに適合しなかっただけなのである。

「ApplicativeをFunctorとMonadの中間段階であるかのように実装に押し込んだために、Zip版の方が厄介に見えてしまった」というのが実情であり、その結果、数学的には等しく正当であるにもかかわらず、不当に`ZipList`という別の型へと追放されることになったのである。

### 2. 型クラス階層という虚構：その構造と数学的正当性の欠如

本章では、前章で示した「歪み」が、いかにして`Functor => Applicative => Monad`という階層構造そのものから生まれているかを詳述する。この階層が圏論的に自然なものではなく、工学的な妥協の産物であること、そして圏論的には等しく正当なApplicative実装が複数存在するため、Haskellの選択には数学的な正当性が欠けていることを明らかにする。

#### Haskellの型クラス階層

```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b

class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b

class Applicative f => Monad f where
  return :: a -> f a
  (>>=) :: f a -> (a -> f b) -> f b
```

#### 圏論的検証：問題に満ちた構造

**1. 「階層」は圏論的な虚構である**

圏論において、`Functor`、`Monad`、`Applicative`は**独立した概念**であり、このような強制的な階層関係にはない。標準的な圏論の教科書（MacLane、Awodeyなど）を調査すると、以下の関係が示されている。

* **Monad**: 自己関手 + 単位 + 乗算 + 結合則/単位則
* **Applicative (緩和モノイド関手)**: 自己関手 + 緩和モノイド構造 + 自然性
* **関係**: MonadからApplicativeを導出することは可能だが、そこに**強制的な階層は存在しない**。MonadとApplicativeは**並行する概念**なのである。

**2. MonadからのApplicative「導出」が内包する問題**

Haskellでは、以下の導出によって「MonadであればApplicativeになれる」とされる。

```haskell
pure = return
f <*> x = f >>= \g -> x >>= \y -> return (g y)
```

しかし圏論的視点では、この導出は自明ではなく、**テンソル強度 (tensorial strength)** と呼ばれる追加の、そして非自明な構造を暗黙に仮定している。これは自然変換 `strength: A ⊗ T(B) → T(A ⊗ B)` であり、Haskellはこれが全ての型に対して存在すると暗黙に仮定しているが、この仮定は**数学的に非自明**である。

#### 数学的正当性の欠如：圏論的視点

**1. 圏論における複数の積の存在**

圏論からの決定的な事実は、Applicative Functorが**緩和モノイド関手 (lax monoidal functors)** に対応し、そして**モノイド積は（同型を除いて）一意ではない**ということである。これは、同じ圏に複数の異なるモノイド構造が、**数学的に等しい正当性**をもって共存できることを意味する。`List`のような単一の型に対して、複数の「積」が存在するのだ。

* **デカルト積的な構造**: 全ての組み合わせを生成する。
    `[f1,f2] <*> [x1,x2,x3] = [f1 x1, f1 x2, f1 x3, f2 x1, f2 x2, f2 x3]`
* **点ごとの(Zip)構造**: 対応する要素を組み合わせる。
    `[f1,f2] <*> [x1,x2] = [f1 x1, f2 x2]`

これらの構造は**両方とも**、モノイド則（結合則、単位則）や緩和モノイド関手の条件を満たす、完全に圏論的に正当なものである。一方が他方より「自然」あるいは「理論的」であることは、**数学的にあり得ない**。

**2. Haskellの恣意的な選択と正当化**

数学的に正当な複数の選択肢を前に、Haskellは`[]`の`Applicative`を「デカルト積」に恣意的に固定し、等しく正当なZip版を`ZipList`という別の型に追放した。この選択の真の動機は圏論とは無関係であり、**純粋に工学的な理由**に基づいていた。

1.  **Monadとの一貫性**: `[]`の`Monad`インスタンスは、既にデカルト積的な振る舞いであった。
2.  **型推論の予測可能性**: 曖昧なインスタンスによるコンパイルエラーを避けるため。
3.  **歴史的経緯**: ApplicativeはMonadよりずっと後（2008年にConor McBrideとRoss Patersonにより）に言語に追加され、既存のMonadコードとの互換性が求められた。これが、MonadからApplicativeを機械的に導出する階層構造という妥協に繋がった。

#### 階層がもたらす具体的な理論的矛盾

この人工的な階層は、数々の理論的矛盾を生み出している。

* **ZipListが証明する破綻**: `ZipList`はApplicativeであるが、まさにこの階層のせいでMonadにはなれない。もし階層が「自然」なら、なぜZip構造だけが排除されるのか。
* **Set関手の問題**: `Set`はFunctorであるが、`Applicative`になるためには`Ord`制約が必要となり、階層の「純粋な」構造を破壊する。
* **IOモナドの特殊性**: `IO`の`>>=`は逐次実行を意味し、圏論的な`bind`とは意味合いが異なり、その`Applicative`インスタンスの並列的なセマンティクスとも乖離している。

### 3. 「理論的に誠実な」実装：他言語との比較による検証

この問題が数学的な自由度の問題であるという事実に基づき、本章では、他の多くの言語がいかにして単一の型に対して複数のApplicative的な振る舞いを、より自然で、柔軟で、そして完全に安全な方法で実装しているかを示す。「複数の実装は安全性や型システムの一貫性を損なう」という議論は、誤りである。

#### MLファミリー言語の自由度（例：F#）

F#のようなMLファミリー言語は、**関数ベース**のアプローチを取り、異なるセマンティクスを持つ複数の操作を同じ型に対して定義できる。利用者の意図は特定の関数名によって明確になり、曖昧さは生じない。

```fsharp
// 同じList型に複数のApplicative的演算を定義できる
let mapCartesian f xs ys =
    xs |> List.collect (fun x -> ys |> List.map (f x))

let mapZip f xs ys =
    List.map2 f xs ys

// 明示的な関数呼び出しが意図を明確にする
List.map2 (+) [1;2] [3;4]     // Zip版: [4;6]
// List.allPairs (+) [1;2] [3;4] // デカルト積版の例
```

これは「安全性」の問題ではなく、**API設計思想**の違いである。

* **Haskell**: 「同じ抽象操作は、同じ意味であるべきだ」
* **MLファミリー**: 「異なる操作は、異なる名前を持つべきだ」

#### 他言語における解決済みの問題

「複数のインスタンスは型推論を破壊する」という主張は事実に反し、他の多くの言語で解決済みである。

* **Scala**は`implicit`パラメータを用いることで複数のインスタンスの共存を許容し、利用箇所で明示的に選択する。
    ```scala
    // 複数のApplicativeインスタンスが存在
    implicit val listCartesian: Applicative[List] = ...
    implicit val listZip: Applicative[List] = ...

    // 利用時に明示的に選択
    compute(List(1,2), List(3,4))(listCartesian) // デカルト積
    compute(List(1,2), List(3,4))(listZip)       // Zip
    ```
* **Rust**も複数のトレイト実装を許容している。同様の解決策は**Swift、Kotlin、そしてPureScript**においてさえ採用されている。

#### JavaScript：最も身近な反例

世界で最も広く使われているJavaScriptの`Array`は、この柔軟なアプローチが何の問題もなく機能することを証明している。厄介な`new ZipArray()`のような型を必要とせず、単一の`Array`型の上で全ての構造を選択的に、自由に、そして明確に利用することが可能である。

* **Functor**: `Array.prototype.map`が標準で提供されている。
* **Monad**: `Array.prototype.flatMap`も標準で提供され、自然にデカルト積的な振る舞いを表現できる。
* **Applicative**: 標準ではないが、両方の振る舞いを容易に実装できる。
    ```javascript
    // Zip版
    const mapZip = (f, xs, ys) => xs.map((x, i) => f(x, ys[i]));

    // デカルト積版
    const mapCartesian = (f, xs, ys) => xs.flatMap(x => ys.map(y => f(x, y)));
    ```

これは、Haskellの制約が普遍的なものではなく、厳密にHaskell固有の型クラスシステムの設計上の選択であることを示している。

### 4. 権威的主張のケーススタディ：「ZipListはMonadになれない」言説

本章では、Haskellの特異な設計思想が生み出した具体的な「ケーススタディ」として、Haskellにおける有名な主張を再検討し、「数学的事実」と「Haskellのローカルルール」がいかに混同されているかの言説構造を明らかにする。Haskellコミュニティ内では、しばしば以下の主張が権威をもって述べられる。

> **「ZipListがMonadになることは、数学的に不可能である」**

この主張は広く受け入れられており、GitHub上のCoqによる証明や、Haskell-cafeメーリングリスト、StackOverflowでの古典的な例として扱われている。そして実際に、`ZipList`に対してモナド則、特に結合法則を満たすように`>>=`を定義することは困難である。

```haskell
-- モナド則を満たすように定義することは困難である
zipBind :: ZipList a -> (a -> ZipList b) -> ZipList b
```

**結合法則**: `(m >>= f) >>= g` == `m >>= (\x -> f x >>= g)`

この法則は、計算がどのように順序付けられても結果が変わらないことを保証する。Zip操作に基づく実装では、リストの長さや構造が複雑に変化するケースでこの法則を満たすことができない。

この「不可能性」は、Haskellのローカルルールではなく、純粋な数学的要請である。しかし問題は、この事実が、Haskellの人工的な階層構造や、デカルト積を標準とする恣意的な選択を正当化するために利用されている点にある。核心的な問題は、数学的事実そのものではなく、それがコミュニティの言説の中でいかに道具化されているかという点なのだ。

### 5. 知的態度の問題：「理論的権威」の濫用

本章では、これまでの議論を統合し、Haskellコミュニティに見られる、権威主義や理論の濫用といった、より深刻な問題を批判する。これは時に「圏論ロンダリング」とも呼ばれる。

#### 圏論ロンダリング

工学的な都合を「圏論的に美しい」あるいは「数学的な必然性」として正当化し、設計上の問題点を「理論的な深み」として美化する傾向が存在する。デカルト積を恣意的に「標準」の座に就かせ、数学的に等価なZip構造を追放するという論理的破綻の産物である`ZipList`の存在が、にもかかわらず「設計のエレガンス」としてしばしば正当化される。

この「ロンダリング」はいくつかのパターンで現れる。

* **チュートリアルにおける聖典化**: 「デカルト積はApplicativeの自然な実装である」「型クラス階層は圏論的構造を反映している」といった説明が、圏論的な根拠がないにもかかわらず一般的である。
* **学術的権威の濫用**: 実際の圏論的証明を提示することなく、「圏論」というキーワードを権威付けに利用する。
* **無批判な再生産**: 確立された主張を「公式見解」として流通させ、批判的な検証を欠き、他言語の反例を組織的に無視する。

#### 「設計思想」という逃げ道と典型的な防御

理論的根拠がないことが明らかになると、「哲学」や「美学」といった主観的な領域に逃避し、批判を「理解不足」として退けるという戦術がよく見られる。しかし、`class Functor f => Applicative f => Monad f`という階層は、いかなる点で「哲学的に美しい」というのだろうか。異なる操作に異なる名前を与えるMLファミリーのアプローチの方が、はるかに明快かつ自然である。

実際の議論では、以下の**パターン化された防御**が頻繁に現れる。

* **「型推論の一貫性」**: 複数の実装は型推論を破壊すると主張する。**現実**: これは他言語における解決済みの問題である。Haskellの設計上の制約を、普遍的な問題として提示している。
* **「数学的必然性」**: デカルト積は「自然」で、Zipは「人工的」だと主張する。**現実**: 圏論的には等価である。恣意的な選択を、理論的な正当化として提示している。
* **「設計思想」**: 統一されたインターフェースは「美しい」と主張する。**現実**: 数学的に等価な構造を分離するための`newtype`の濫用自体が醜い。工学的な妥協を、美学として再パッケージしている。

圏論的には全く不自然な制約（型クラスごとの実装は一つ）を通じて、Haskellはデカルト積を「標準」として恣意的に選択し、Zip構造を`ZipList`という人工的な別の型へと追放する。そして、この論理的破綻を「設計のエレガンス」として後付けで正当化し、あたかもそこに数学的必然性があったかのように見せかける。これは、知的誠実さの欠如を示す典型例である。

### 結論：真の理論的誠実さを求めて

Haskellが関数型プログラミングの世界に与えた貢献は計り知れない。しかし、その偉大な権威の影で、**工学的あるいは歴史的な設計上の選択を、「数学的必然性」や「理論的優位性」という後付けの物語で正当化する傾向**という、特定の問題が存在する。`List`のApplicative実装をデカルト積に固定し、`ZipList`という解決策を必要とさせた一連の経緯は、その最も象徴的な例である。

真の理論的誠実さは、自らの言語が持つ制約と設計上のトレードオフを率直に認めることから始まる。

#### あるべき姿勢

1.  **複数の正当な実装を認めること**: 圏論が示すように、`List`には複数の`Applicative`構造が存在しうることを認識する。
2.  **工学的制約と理論を混同しないこと**: 「型クラスの一意性」はHaskellの工学的な選択であり、普遍的な数学的真理ではないことを明確にする。
3.  **圏論的概念を正確に適用すること**: `Monad`や`Applicative`といった概念を、正当化や権威付けの目的で利用しない。
4.  **他言語の解決策を尊重すること**: F#、Scala、JSなどに見られる、より柔軟で、ある意味でより圏論的に自然なアプローチから学ぶ。
5.  **「公式見解」を批判的に再検証すること**: コミュニティ内で定着した言説であっても、常にその理論的根拠を問い直す。

Haskellがリーダーシップを持つからこそ、自らの設計の背後にある工学的な判断や歴史的文脈を正直に説明すべきであり、「妥協」を「必然」と主張すべきではない。自ら「理論的権威」という覆いを脱ぎ捨て、設計上のトレードオフをオープンに議論することによって、Haskellは真の尊敬を勝ち取り、プログラミング言語の進化をリードし続けることができるだろう。